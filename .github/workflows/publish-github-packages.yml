name: Release Desktop Installers

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Validate
        run: |
          npm run typecheck
          npm run test
          npm run build

  package-installers:
    name: Package (${{ matrix.platform }})
    needs: validate
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            platform: macOS
            package_command: npm run desktop:package:mac
          - os: windows-latest
            platform: Windows
            package_command: npm run desktop:package:win

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Set app version from tag
        shell: bash
        env:
          TAG_NAME: ${{ github.ref_name }}
        run: |
          VERSION="${TAG_NAME#v}"
          npm version "${VERSION}" --no-git-tag-version --allow-same-version

      - name: Prepare macOS signing credentials
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          MACOS_CERTIFICATE_P12_BASE64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          APPLE_NOTARY_KEY_P8: ${{ secrets.APPLE_NOTARY_KEY_P8 }}
          APPLE_NOTARY_KEY_ID: ${{ secrets.APPLE_NOTARY_KEY_ID }}
          APPLE_NOTARY_ISSUER_ID: ${{ secrets.APPLE_NOTARY_ISSUER_ID }}
        run: |
          set -euo pipefail

          for required_var in MACOS_CERTIFICATE_P12_BASE64 MACOS_CERTIFICATE_PASSWORD APPLE_NOTARY_KEY_P8 APPLE_NOTARY_KEY_ID APPLE_NOTARY_ISSUER_ID; do
            if [ -z "${!required_var:-}" ]; then
              echo "::error title=Missing secret::${required_var} is required for macOS signed release builds."
              exit 1
            fi
          done

          CERT_PATH="${RUNNER_TEMP}/macos-signing-cert.p12"
          printf '%s' "${MACOS_CERTIFICATE_P12_BASE64}" | base64 -D > "${CERT_PATH}"

          NOTARY_KEY_PATH="${RUNNER_TEMP}/AuthKey_${APPLE_NOTARY_KEY_ID}.p8"
          printf '%s' "${APPLE_NOTARY_KEY_P8}" > "${NOTARY_KEY_PATH}"

          chmod 600 "${CERT_PATH}" "${NOTARY_KEY_PATH}"

          {
            echo "CSC_LINK=${CERT_PATH}"
            echo "CSC_KEY_PASSWORD=${MACOS_CERTIFICATE_PASSWORD}"
            echo "APPLE_API_KEY=${NOTARY_KEY_PATH}"
            echo "APPLE_API_KEY_ID=${APPLE_NOTARY_KEY_ID}"
            echo "APPLE_API_ISSUER=${APPLE_NOTARY_ISSUER_ID}"
            echo "CSC_IDENTITY_AUTO_DISCOVERY=false"
          } >> "${GITHUB_ENV}"

      - name: Prepare Windows signing credentials
        if: matrix.os == 'windows-latest'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PFX_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_PFX_BASE64 }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PFX_BASE64)) {
            throw "WINDOWS_CERTIFICATE_PFX_BASE64 is required for Windows signed release builds."
          }

          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PASSWORD)) {
            throw "WINDOWS_CERTIFICATE_PASSWORD is required for Windows signed release builds."
          }

          $certPath = Join-Path $env:RUNNER_TEMP "windows-signing-cert.pfx"
          [System.IO.File]::WriteAllBytes($certPath, [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE_PFX_BASE64))

          @(
            "WIN_CSC_LINK=$certPath"
            "WIN_CSC_KEY_PASSWORD=$env:WINDOWS_CERTIFICATE_PASSWORD"
            "CSC_LINK=$certPath"
            "CSC_KEY_PASSWORD=$env:WINDOWS_CERTIFICATE_PASSWORD"
            "CSC_IDENTITY_AUTO_DISCOVERY=false"
          ) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Build installer (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          ulimit -n 10240
          ${{ matrix.package_command }}

      - name: Build installer (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          ${{ matrix.package_command }}

      - name: Verify macOS code signing and notarization
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          set -euo pipefail

          APP_PATH="$(find dist/installers -type d -name 'Local Playground.app' | head -n 1)"
          if [ -z "${APP_PATH}" ]; then
            echo "::error::Signed app bundle was not found under dist/installers."
            exit 1
          fi

          DMG_PATH="$(find dist/installers -maxdepth 1 -type f -name '*.dmg' | head -n 1)"
          if [ -z "${DMG_PATH}" ]; then
            echo "::error::DMG installer was not found under dist/installers."
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "${APP_PATH}"
          spctl --assess --type execute --verbose=4 "${APP_PATH}"
          xcrun stapler validate "${APP_PATH}"
          xcrun stapler validate "${DMG_PATH}"

      - name: Verify Windows Authenticode signatures
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $targets = Get-ChildItem -Path "dist/installers" -Filter "*.exe" -File
          if (-not $targets) {
            throw "Windows installer (.exe) was not found under dist/installers."
          }

          foreach ($target in $targets) {
            $signature = Get-AuthenticodeSignature -FilePath $target.FullName
            if ($signature.Status -ne "Valid") {
              throw "Invalid Authenticode signature: $($target.Name) status=$($signature.Status)"
            }
          }

      - name: Upload macOS installers
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: installers-macos
          path: |
            dist/installers/*.dmg
            dist/installers/*.zip
          if-no-files-found: error

      - name: Upload Windows installers
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: installers-windows
          path: |
            dist/installers/*.exe
            dist/installers/*.msi
            dist/installers/*.zip
          if-no-files-found: error

  release:
    name: Publish Release Assets
    needs: package-installers
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download installers
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Publish release notes and assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          mapfile -t ASSETS < <(find release-assets -type f | sort)
          if [ "${#ASSETS[@]}" -eq 0 ]; then
            echo "No installer assets were found."
            exit 1
          fi

          cat > release-notes.md <<'EOF'
          ## Local Playground

          Desktop installers for macOS / Windows are attached to this release.

          ### Run from Source (Copy & Paste)

          ```bash
          git clone https://github.com/anaregdesign/local-playground.git
          cd local-playground
          npm install
          az login
          npm run dev
          ```

          Open: `http://localhost:5173`

          ### Installer Assets

          ### Platform Trust
          - macOS artifacts are Developer ID signed and notarized.
          - Windows installers are Authenticode signed and timestamped.
          EOF

          for asset in "${ASSETS[@]}"; do
            printf -- '- `%s`\n' "$(basename "${asset}")" >> release-notes.md
          done

          if gh release view "${TAG_NAME}" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            gh release edit "${TAG_NAME}" --repo "${GITHUB_REPOSITORY}" --title "${TAG_NAME}" --notes-file release-notes.md
          else
            gh release create "${TAG_NAME}" --repo "${GITHUB_REPOSITORY}" --title "${TAG_NAME}" --notes-file release-notes.md
          fi

          gh release upload "${TAG_NAME}" --repo "${GITHUB_REPOSITORY}" "${ASSETS[@]}" --clobber
